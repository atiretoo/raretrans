---
title: "Effect of prior information on transition probabilities"
author: "Drew Tyre"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Effect of prior information on transition probabilities}
  %\VignetteEngine{knitr::rmarkdown}
  \VignetteEncoding{UTF-8}
bibliography: references.bib
---

## Borrowing strength

Tremblay and McCarthy [-@tremblay2014bayesian] estimated transition probabilities and recruitment rates for another epiphytic orchid from a series of small populations. Although some transitions were not observed in all populations, the presence of a few observations in other populations allowed the statistical models to "borrow strength" from each other and generate estimated probabilities for all transitions. Unfortunately, many (45%; @SalgueroCompadre2015) plant demography studies are carried out at single sites . In those cases there is no information to fill in the blanks for non-observed transitions. 

Here we explore the population consequences of setting a prior accounting for counting constraints. Ignoring the problem treats the transition as a fixed zero. This can have severe consequences for matrix structure [@stott2010reducibility]. The observed transitions are multinomial rather than binomial events. This can be accommodated by using a Dirichlet prior distribution, albeit at the cost of increased complexity in the calculations. 
@eberhardt1986grizzly had a small sample size of grizzlies in some age classes. Morris and Doak [pg 197, -@morris2002quantitative] recognized the potential problem with small sample sizes for rare transitions, but their recommendation is to use the mathematically more complex approach of Tremblay and McCarthy [-@tremblay2014bayesian]. Is there anything that can be done on the simple side?

## The matrix

We will use observations of an epiphytic Orchid *L. elto*. 

```{r, message=FALSE}
library(tidyverse)
library(popbio)
library(raretrans)
knitting <- isTRUE(getOption('knitr.in.progress'))
if(!knitting){
  pathtoimages="images"
#   # login to imgur
#   library(imguR)
#   imgurtkn <- imgur_login()
#   imgurtkn$refresh()
}
# Raymond's theme modifications
rlt_theme <- theme(axis.title.y = element_text(colour="grey20",size=15,face="bold"),
        axis.text.x = element_text(colour="grey20",size=15, face="bold"),
        axis.text.y = element_text(colour="grey20",size=15,face="bold"),  
        axis.title.x = element_text(colour="grey20",size=15,face="bold"))
data("L_elto")
A <- projection.matrix(as.data.frame(L_elto), stage="stage", fate="next_stage", fertility="fertility",
                       sort=c("p","j","a"))
knitr::kable(A, digits=2)
```

The average population growth rate over all years and populations is `r format(popbio::lambda(A), digits=2)`, suggesting a rapid decline. 

```{r pop_by_time, fig.cap = "Population size over time.", fig.show='hold'}
plotdata <- L_elto %>% group_by(POPNUM, year, stage) %>%
  tally() %>%
  group_by(POPNUM, year) %>%
  summarise(N = sum(n))

gg1 <- ggplot(plotdata, aes(x=year, y=N, group=POPNUM)) +
  geom_line() + rlt_theme
plotsumm <- plotdata %>% group_by(year) %>%
  summarize(N=sum(N))
gg2 <- ggplot(plotsumm, aes(x=year, y=N)) +
  geom_line() + rlt_theme
ggboth <- gridExtra::grid.arrange(gg1, gg2)

if(!knitting){
  ggsave("pop_by_time.png", plot=ggboth, device="png", path=pathtoimages)
} 
ggboth

```

OK, now we want to generate matrices for each year and popnum. We have to change the variables into factors and control the levels so that the resulting matrices end up with the right shape with zeros for the missing transitions. Also have to coerce each grouped tbl_df to a regular data.frame before passing to `projection.matrix()`. 
```{r}
allA <- L_elto %>% 
  mutate(stage = factor(stage, levels=c("p","j","a","m")),
         fate = factor(next_stage, levels=c("p","j","a","m"))) %>%
  group_by(POPNUM, year) %>%
  do(A = projection.matrix(as.data.frame(.), 
                           stage="stage", fate="fate", 
                           fertility="fertility", sort=c("p","j","a")),
     TF = projection.matrix(as.data.frame(.), 
                           stage="stage", fate="fate", 
                           fertility="fertility", sort=c("p","j","a"), TF = TRUE),
     N = get_state_vector(as.data.frame(.), 
                           stage="stage", sort=c("p","j","a"))) %>%
  
  filter(year < 12) # last year all zero for obvious reason

```

We end up with all the matrices for each population and year in a `list-column` of the result. Working with this thing is a bit awkward. The best strategy is from [Jenny Bryans' talk on list columns](https://speakerdeck.com/jennybc/putting-square-pegs-in-round-holes-using-list-cols-in-your-dataframe) and uses mutate with map_*(listcolumn, function).

```{r histLmbdaByYear, message=FALSE, fig.cap="histograms of asymptotic population growth for each year."}

library(popdemo)
allA <- ungroup(allA) %>% 
  mutate(A = map(A, matrix, nrow=3, ncol=3,
                 dimnames=list(c("p","j","a"),c("p","j","a")))) %>%
  mutate(lmbda = map_dbl(A, lambda),
         ergodic = map_dbl(A, is.matrix_ergodic),
         irreduc = map_dbl(A, is.matrix_irreducible),
         primitv = map_dbl(A, is.matrix_primitive))
ggplot(allA, aes(x=lmbda)) + geom_histogram() + facet_wrap(~year)+
 ylab("Frequency")+
  xlab(expression(paste(lambda, ", asymptotic population growth"))) + rlt_theme
  
if(!knitting){
  ggsave("histLmbdaByYear.png", path=pathtoimages)
}
```

Now, we need to figure out how many matrices are missing transitions. The full matrix has observed transitions in every cell. 

```{r checkErgIrr1}
allA <- ungroup(allA) %>% mutate(missing = map(A, ~which(.x==0)),
                                 n_missing = map_dbl(missing, length))
missing_summary <- summary(allA$n_missing)
ergo_irr <- as.data.frame(with(allA, table(ergodic, irreduc)))

knitr::kable(ergo_irr, caption = "Ergodicity and irreducibility of individual transition matrices.")
```

Out of 11 years and `r length(unique(allA$POPNUM))` populations there are a total of `r nrow(allA)` transition matrices. Some years are missing for some populations. Only `r ergo_irr[4,3]` of these matrices are irreducible. All of the matrices have 2 or more transitions that are zero but known to be possible. 

```{r exampleMatrices, echo=FALSE}
#144 popn 905 year 9 10 individuals go extinct
badA144 <- allA$A[[144]]
badN144 <- allA$N[[144]]
#205 popn 914 year 6 lambda == 1 
badA205 <- allA$A[[205]]
badN205 <- allA$N[[205]]
badA71 <- allA$A[[71]]
badN71 <- allA$N[[71]]
#71 popn 250 year 5 lambda = 0.93
BaseTable <- 
  tribble(~Population, ~Year, ~Stage,     ~N,        ~seedling,    ~juvenile,   ~adult,
          905,             9, "seedling", badN144[1], badA144[1,1],badA144[1,2],badA144[1,3],
          905,             9, "juvenile", badN144[2], badA144[2,1],badA144[2,2],badA144[2,3],
          905,             9, "adult",    badN144[3], badA144[3,1],badA144[3,2],badA144[3,3],
          914,             6, "seedling", badN205[1], badA205[1,1],badA205[1,2],badA205[1,3],
          914,             6, "juvenile", badN205[2], badA205[2,1],badA205[2,2],badA205[2,3],
          914,             6, "adult",    badN205[3], badA205[3,1],badA205[3,2],badA205[3,3],
          250,             5, "seedling", badN71[1], badA71[1,1],badA71[1,2],badA71[1,3],
          250,             5, "juvenile", badN71[2], badA71[2,1],badA71[2,2],badA71[2,3],
          250,             5, "adult",    badN71[3], badA71[3,1],badA71[3,2],badA71[3,3])


# make some space for the prior versions
RLT_Tprior <- matrix(c(0.25, 0.025, 0.0,
                       0.05, 0.9,   0.025,
                       0.01, 0.025, 0.95,
                       0.69, 0.05,  0.025), 
                     byrow = TRUE, nrow = 4, ncol = 3)
RLT_Fprior <- matrix(c(0.0, 0.0, 0.025,
                       0.0, 0.0, 0.0,
                       0.0, 0.0, 0.0), 
                     byrow = TRUE, nrow = 3, ncol = 3)

wUnifTable <- bind_cols(BaseTable, BaseTable[,5:7], BaseTable[,5:7])
wUnifTable[1:3, 8:10] <- fill_transitions(allA$TF[[144]], allA$N[[144]])
wUnifTable[4:6, 8:10] <- fill_transitions(allA$TF[[205]], allA$N[[205]])
wUnifTable[7:9, 8:10] <- fill_transitions(allA$TF[[71]], allA$N[[71]])
wUnifTable[1:3, 11:13] <- fill_transitions(allA$TF[[144]], allA$N[[144]], P = RLT_Tprior, priorweight = -1)
wUnifTable[4:6, 11:13] <- fill_transitions(allA$TF[[205]], allA$N[[205]], P = RLT_Tprior, priorweight = -1)
wUnifTable[7:9, 11:13] <- fill_transitions(allA$TF[[71]], allA$N[[71]], P = RLT_Tprior, priorweight = -1)
knitr::kable(wUnifTable, caption = "Two problematic matrices and the matrix with the largest sample size; $\\lambda$ = 0, 1, and 0.92 for population 905, 914 and 205 respectively. The six columns on the right show the effect of assuming a uniform prior for transitions with a total weight of 1, and an RLT prior with total weight equal to 1.  Where columns do not sum to 1 the remaining probability represents mortality.", digits=3, escape = TRUE)
```

## Ignore the problem

Ignoring this problem and calculating stochastic $\lambda$ for each population could yield non-sensical results. For example, the geometric mean $\lambda$ calculated using simulation often fails. 

```{r stochGrowthRateBad}
sgr <- allA %>% split(.$POPNUM) %>%
  map(~stoch.growth.rate(.x$A, verbose = FALSE))

# distribute results of stoch.growth.rate() into a tbl
xtrc <- function(x){
  data.frame(approx=x$approx,
                sim = x$sim,
                lowerci = x$sim.CI[1],
                upperci = x$sim.CI[2])
}
sgr <- bind_rows(map(sgr, xtrc), .id="POPNUM") 
filter(sgr, !is.na(sim)) %>%
ggplot(aes(x=approx, y = sim)) + geom_point() + 
  geom_errorbar(aes(ymin=lowerci, ymax=upperci)) + 
  geom_abline(slope = 1, intercept=0) + 
  rlt_theme +
  xlab(expression(paste("Tuljapurkar's approximate stochastic ", log(lambda)))) +
  ylab(expression(paste("Stochastic ", log(lambda), " by simulation")))
if(!knitting){
  ggsave("stochGrowthRateBad.png", path=pathtoimages)
}
```

The six populations where the simulated values are unavailable have very low approximate growth rates as well. All the stochastic growth rates are less than 1.

## Fill in including constraints

This strategy uses the transitions in a smarter way that maintains the constraint that all survival/transition probabilities have to add up to 1. We do this by using a dirichlet prior with the function `fill_transitions()`. This function takes the matrix as a list of 2 components, a matrix of transition probabilities $T$ and a matrix of fertility contributions $F$. The Dirichlet prior only applies to the $T$ matrix. If not specified, the function assumes a uniform prior across the $m+1$ fates for each stage. The extra category is for individuals that do not survive. 

Show the steps from an observed transition matrix through calculating the priors

```{r fillDirichlet, fig.cap = "Asymptotic growth rate using a uniform prior with a total weight of 1 vs. the asymptotic growth rate for the observed data."}
testing <- allA %>% mutate(Adirch = map2(TF, N, fill_transitions),
                           ldirch = map_dbl(Adirch, lambda),                 
         irrdirch = map_dbl(Adirch, is.matrix_irreducible),
         ergdirch = map_dbl(Adirch, is.matrix_ergodic),
         TN = map2(TF, N, fill_transitions, returnType = "TN"))

ggplot(testing, aes(x=lmbda, y=ldirch)) + geom_point() + 
  geom_abline(slope = 1, intercept=0) +
  xlab(expression(paste(lambda, " ignoring zeros"))) + 
  ylab(expression(paste(lambda, " using a uniform prior"))) +
  rlt_theme
if(!knitting){
  ggsave("fillDirichlet.png", path=pathtoimages)
}
```


The matrices with $\lambda = 0$ typically have very few individuals. Matrices with $\lambda = 1$ usually have transitions only on the main diagonal. 

```{r checkErgIrr}
ergo_irr <- as.data.frame(with(testing, table(ergdirch, irrdirch)))

knitr::kable(ergo_irr, caption = "Ergodicity and irreducibility of individual transition matrices.")

```

```{r stochDirchVsBad}
sgr_unif <- testing %>% split(.$POPNUM) %>%
  map(~stoch.growth.rate(.x$Adirch, verbose = FALSE))

sgr_unif <- bind_rows(map(sgr_unif, xtrc), .id="POPNUM") 
compare_approx <- data_frame(unif = sgr_unif$approx,
                             ignored = sgr$approx)
ggplot(compare_approx, aes(x=ignored, y = unif)) + 
  geom_point() + 
  geom_abline(slope = 1, intercept=0) + 
  xlab(expression(paste("log(",lambda,") ignoring zeros"))) + 
  ylab(expression(paste("log(",lambda,") with uniform prior"))) +
  rlt_theme
if(!knitting){
  ggsave("stochDirchVsBad.png", path=pathtoimages)
}
```

So using a Dirichlet prior to fill in the gaps works, and doesn't appear to distort the stochastic population growth rate; all populations still have negative growth. Most populations end up with stochastic growth rates that are lower than with the problematic matrices. All resulting matrices are now ergodic and irreducible.

## Effects of informative priors

We extracted an informative prior from an expert on epiphytic orchids (RLT) to compare with the uniform prior. In particular, we considered the effects of weighting the prior by different fractions of the actual sample size for each population and year. 

```{r makePriors, eval=FALSE}
RLT_Tprior <- matrix(c(0.25, 0.025, 0.0,
                       0.05, 0.9,   0.025,
                       0.01, 0.025, 0.95,
                       0.69, 0.05,  0.025), 
                     byrow = TRUE, nrow = 4, ncol = 3)
RLT_Fprior <- matrix(c(0.0, 0.0, 0.025,
                       0.0, 0.0, 0.0,
                       0.0, 0.0, 0.0), 
                     byrow = TRUE, nrow = 3, ncol = 3)
```

The RLT prior gives $\lambda = `r format(lambda(RLT_Tprior[-4,] + RLT_Fprior), digits = 2)`$. In an ideal world this prior would be extracted prior to collecting the data. In this case the prior is only being used to demonstrate the technique.

```{r fillDirichletPrior1, fig.cap="Asymptotic growth rates using prior information vs. the raw observations alone. The horizontal red line indicates $\\lambda$ for the RLT prior. Points for all four priors shown in transparent grey."}
diffPriors <- list()
diffPriors[["Uniform"]] <- testing %>% mutate(Aprior = map2(TF, N, fill_transitions),
                                              lprior = map_dbl(Aprior, lambda))


diffPriors[["RLT, weight = 1"]] <- testing %>% mutate(Aprior = map2(TF, N, fill_transitions, 
                                            P=RLT_Tprior),
                             lprior = map_dbl(Aprior, lambda))

diffPriors[["RLT, weight = 0.5N"]] <- testing %>% mutate(Aprior = map2(TF, N, fill_transitions, 
                                            P=RLT_Tprior, priorweight = 0.5),
                             lprior = map_dbl(Aprior, lambda))

diffPriors[["RLT, weight = N"]] <- testing %>% mutate(Aprior = map2(TF, N, fill_transitions, 
                                            P=RLT_Tprior, priorweight = 1),
                             lprior = map_dbl(Aprior, lambda))

diffPriors <- bind_rows(diffPriors, .id="prior")
diffPriors$prior <- factor(diffPriors$prior, levels = c("Uniform", "RLT, weight = 1",
                                                        "RLT, weight = 0.5N", "RLT, weight = N"))
ggplot(diffPriors, aes(x=lmbda, y=lprior)) + 
  geom_point() + 
  geom_point(data=select(diffPriors, -prior), alpha=0.1) + 
  geom_abline(slope = 1, intercept=0, linetype = 2) +
  ylab(expression(paste(lambda, " including prior information"))) + 
  xlab(expression(paste(lambda, " from raw observations"))) + 
  facet_wrap(~prior) + 
  geom_hline(yintercept = 0.96, color="red", linetype = 2 ) + 
  theme_bw() + rlt_theme
if(!knitting){
  ggsave("fillDirichletPrior1.png", path=pathtoimages)
}
```

# Obtaining credible intervals on vital rates and $\lambda$

Recognizing that the observed transitions are realizations of a Dirichlet distribution gives us a very simple way to derive credible intervals for the transition probabilities in our matrix. The marginal distribution of a single transition is a beta distribution as described above, and we can simply report the 2.5% and 97.5% percentiles of that distribution to provide a credible interval on a transition rate. These intervals do shift and shrink as the weight on the prior increases.

```{r credibleIntervals1, echo=FALSE, fig.width = 5, fig.height = 5, fig.cap="Credible intervals for transition probabilities out of seedling stage in Population 250, year 5. Shaded bands correspond to 50% (darkest), 90%, 95% and 99.9% (lightest) credible intervals. Smaller intervals are not visible in the p->a transitions when the upper boundary of the interval is smaller than 0.01. Labels are median (lower 95% CI, upper 95% CI). Note that where the median and lower interval are equal to 0.01, the actual value is < 0.01."}
xx <- crossing(prior = c("None", "Uniform", "RLT, weight = 1", "RLT, weight = 0.5N", "RLT, weight = N"),
         transition = c("p to p", "p to j", "p to a", "p to m"),
         prob = seq(0.01,0.99, 0.01))
params <- tribble(
  ~prior, ~transition, ~a,
  "None", "p to p",     1,    
  "None", "p to j",     7,
  "None", "p to a",     0,
  "None", "p to m",     3,
  "Uniform", "p to p",     1.25,    
  "Uniform", "p to j",     7.25,
  "Uniform", "p to a",     0.25,
  "Uniform", "p to m",     3.25,
  "RLT, weight = 1", "p to p",     1.25,    
  "RLT, weight = 1", "p to j",     7.05,
  "RLT, weight = 1", "p to a",     0.01,
  "RLT, weight = 1", "p to m",     3.69,
  "RLT, weight = 0.5N", "p to p",     2.375,    
  "RLT, weight = 0.5N", "p to j",     7.275,
  "RLT, weight = 0.5N", "p to a",     0.055,
  "RLT, weight = 0.5N", "p to m",     6.795,
  "RLT, weight = N", "p to p",     3.75,    
  "RLT, weight = N", "p to j",     7.55,
  "RLT, weight = N", "p to a",     0.11,
  "RLT, weight = N", "p to m",     10.59
) 
params <- group_by(params, prior) %>%
  mutate(b = sum(a) - a,
         lowerci = qbeta(0.025, a, b),
         median = paste0("median=",format(qbeta(0.5, a, b),digits=0,nsmall=3)),
         upperci = qbeta(0.975, a, b),
         expected = paste0("mean=",format(a / (a+b), digits=0, nsmall=3)),
         x = 0.9, y=12) %>%
  ungroup()

xx <- left_join(xx, params, by = c("prior", "transition")) %>%
  mutate(dens = dbeta(prob, a, b),
         inci = prob > lowerci & prob < upperci) 
xx$prior <- factor(xx$prior, levels = c("None", "Uniform", "RLT, weight = 1", "RLT, weight = 0.5N", "RLT, weight = N"))
xx$transition <- factor(xx$transition, levels = c("p to p", "p to j", "p to a", "p to m"))

params$transition <- factor(params$transition, levels = c("p to p", "p to j", "p to a", "p to m"))
# fix alphas
# see discussions at https://stackoverflow.com/questions/17311917/ggplot2-the-unit-of-size 
# to see where I get the conversion factor for points - size to keep fonts the same.
ggplot(filter(xx, transition != "p to m"), aes(x = prob, y=dens)) + geom_area(alpha = 0.75) +
  geom_area(data=function(x){x[x$inci,]}) +
  theme_classic() +
  facet_grid(prior~transition) + #, labeller=label_wrap_gen(width = 15)) + 
  xlab("Transition Probability") + 
  ylab("Probability Density") + 
  geom_text(data=filter(params, transition != "p to m"), 
            mapping=aes(x=x,y=y, label=expected),
            size=12/.pt, hjust=1) +
  geom_text(data=filter(params, transition != "p to m"), 
            mapping=aes(x=x,y=y-3, label=median),
            size=12/.pt, hjust=1) + 
  rlt_theme + theme(panel.spacing = unit(1, "lines"),
                    strip.text = element_text(size=12)) +
  scale_x_continuous(breaks = c(0,0.5,1.0))
if(!knitting){
  ggsave("credibleIntervals1.png", path=pathtoimages)
}
```

Obtaining credible intervals on $\lambda$ requires simulation, because it is difficult (or maybe impossible) to use the characteristic equation to combine the probability distributions of the matrix entries to obtain the distribution of $\lambda$. 

```{r lambda_ci, fig.cap="Distribution of asymptotic population growth rates for population 250, year 5, with different prior information."}
#71 popn 250 year 5 lambda = 0.93
diffPriors_lci <- list()
samples = 10000
diffPriors_lci[["Uniform"]] <- data_frame(A = sim_transitions(allA$TF[[71]], allA$N[[71]], samples = samples), 
                                          lprior = map_dbl(A, lambda))


diffPriors_lci[["RLT, weight = 1"]] <- data_frame(A = sim_transitions(allA$TF[[71]], allA$N[[71]], P=RLT_Tprior, samples = samples), 
                                          lprior = map_dbl(A, lambda))

diffPriors_lci[["RLT, weight = 0.5N"]] <- data_frame(A = sim_transitions(allA$TF[[71]], allA$N[[71]], 
                                                                        P=RLT_Tprior, priorweight = 0.5,
                                                                        samples = samples), 
                                                    lprior = map_dbl(A, lambda))

diffPriors_lci[["RLT, weight = N"]] <- data_frame(A = sim_transitions(allA$TF[[71]], allA$N[[71]], 
                                                                        P=RLT_Tprior, priorweight = 1,
                                                                        samples = samples), 
                                                    lprior = map_dbl(A, lambda))

diffPriors_lci <- bind_rows(diffPriors_lci, .id="prior")
diffPriors_lci$prior <- factor(diffPriors_lci$prior, levels = c("Uniform", "RLT, weight = 1",
                                                        "RLT, weight = 0.5N", "RLT, weight = N"))

ggplot(diffPriors_lci, aes(x=lprior)) + 
  geom_density(fill="black") + 
  facet_wrap(~prior) + 
  theme_bw()
if(!knitting){
  ggsave("credible_lambda.png", path=pathtoimages)
}
```

```{r uploadGoogleDrive, eval=!knitting, echo=FALSE, include=FALSE}
library(googledrive)
images <- list.files(path=pathtoimages, full.names=TRUE)
# first time do this
# imgDrive <- list()
# for (i in seq_along(images)){
#   imgDrive[[i]] <- drive_upload(media=images[i],
#                path="raretrans/images/")  
# }
# imgIDs <- map_chr(imgDrive,"id")
# doesn't work with multiple ids
#drive_share(as_id(imgIDs[1]), role="reader", type="anyone")
# need to remove the /view?usp=drivesdk at the end?
# drive_share_link(as_id(imgIDs)) 

# dput(imgIDs)

imgIDs <- c("0Bxs6Le-YI-kdakkza0Zld1FXR2c", "0Bxs6Le-YI-kdbFBGamdEY093d28", 
"0Bxs6Le-YI-kdR3dSMzd5cVBiZlE", "0Bxs6Le-YI-kdRXZMdWFRZTFmeWc", 
"0Bxs6Le-YI-kda3FyM0wtY3hfdFk", "0Bxs6Le-YI-kdWDctbVJQTzZjZm8", 
"0Bxs6Le-YI-kdUmt4aXB2RkoyYmc")

if (length(images) != length(imgIDs)) {
  stop("you've added new images, delete everything and rerun startup code.")
}

for (i in seq_along(images)){
  imgDrive[[i]] <- drive_update(file=as_id(imgIDs[i]),media=images[i])
}

```

# References
