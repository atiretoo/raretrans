---
title: "Simulation Studies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulation Studies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(huxtable.add_colnames = FALSE,
        digits = 3)
```

```{r setup}
library(raretrans)
library(tidyverse)
library(popbio)
library(popdemo)
library(huxtable)

# Raymond's theme modifications
rlt_theme <- theme(axis.title.y = element_text(colour="grey20",size=15,face="bold"),
        axis.text.x = element_text(colour="grey20",size=15, face="bold"),
        axis.text.y = element_text(colour="grey20",size=15,face="bold"),  
        axis.title.x = element_text(colour="grey20",size=15,face="bold"))
```

Reviewers have asked for a simulation study to confirm that the approach works. 
We will start with two different "true" matrices, simulate observed data from
these, and then use different priors to evaluate how the method works. 

# Calathea, an understory herb

The first example comes from `popbio::calathea` containing matrices published in
Horvitz and Schemske (1995). There are 4 plots and up to 5 years of transitions,
as well as a pooled matrix. Many of the transitions are very small probabilities. The pooled matrix is both ergodic and irreducible, and has a population growth rate of 
`r (true_lambda <- lambda(calathea$pooled))`. 


```{r}
calathea$pooled
```

We begin by simulating a data frame with N observations of plants. 
The initial population will be sampled from the stable stage distribution.
The function `raretrans::sim_transition` doesn't quite do what we 
want because it returns matrices, and we want the underlying observations.
Maybe that's what sim_transition should do, but it doesn't.

```{r}
TF <- splitA(calathea$pooled, r = 1, c = 3:8)
df <- sim_observations(TF)
tail(df) # more interesting
```

```{r}
projection_matrix(df, stage = "stage", fate = "fate", fertility = "Sd")
```
OK, so seems to work with the modified `projection_matrix`. Now we
generate a number of samples to work with, calculating some 
matrix statistics along the way.

```{r, warning=FALSE}
results <- tibble(observations = map(1:100, function(x)sim_observations(TF, N = 100)),
       TF = map(observations, projection_matrix, fertility = "Sd", TF = TRUE),
       N = map(observations, get_state_vector),
       Tunif = map2(TF, N, fill_transitions),
       Funif = map2(TF, N, fill_fertility),
       A = map(TF, ~.x$T+.x$F),
       Aunif = map2(Tunif, Funif, ~.x + .y)) %>% 
  mutate(lambdaraw = map_dbl(A, lambda),
         lambdaunif = map_dbl(Aunif, lambda))
ggplot(data = results) + 
  geom_point(mapping = aes(x = lambdaraw, y = lambdaunif)) + 
  geom_hline(yintercept = lambda(TF$T + TF$F))
```
The uniform prior clearly causes issues by creating values of 1 in the fertility 
matrix for all stages that are not represented in the sample. 

Now we need to create some priors for this plant. Start with samples of size 1
for transitions known to be possible. 

fix it so prior is > 0 but very small unless zeros are "structural".
Structural zeros should never be updated even if an observation is made. 

Fertility priors will be 0 except 
for stages known to reproduce, and these will be set close to zero.

```{r}
set.seed(9347905)
transition_prior <- rbind(TF$T > 0, rep(1, times = ncol(TF$T)))
column_sums <- apply(transition_prior, 2, sum)
transition_prior <- sweep(transition_prior, 2, column_sums, `/` )
fertility_alpha <- TF$F * 0
fertility_alpha[1, 3:8] <- 1e-5
fertility_beta <- TF$F * 0 + (1-1e-5) # to keep sum = 1 
results <- tibble(observations = map(1:100, function(x)sim_observations(TF, N = 100)),
       TF = map(observations, projection_matrix, fertility = "Sd", TF = TRUE),
       N = map(observations, get_state_vector),
       Tunif = map2(TF, N, fill_transitions, P = transition_prior),
       Funif = map2(TF, N, fill_fertility, alpha = fertility_alpha, beta = fertility_beta),
       A = map(TF, ~.x$T+.x$F),
       Aunif = map2(Tunif, Funif, ~.x + .y)) %>% 
  mutate(lambdaraw = map_dbl(A, lambda),
         bootraw = map(observations, boot.transitions, iterations = 1000),
         lci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.025)),
         uci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.975)),
         lambdaunif = map_dbl(Aunif, lambda))
ggplot(data = results) + 
  geom_point(mapping = aes(x = lambdaraw, y = lambdaunif)) + 
  geom_hline(yintercept = lambda(TF$T + TF$F)) + 
  geom_errorbarh(mapping = aes(xmin = lci_raw, xmax = uci_raw, y = lambdaunif))
```

OK, that looks shit. Bootstrapping from problematic matrices leads to non-sensical confidence limits?

```{r}
ggplot(data = results) +
  geom_point(mapping = aes(x = 1:100, y = lambdaraw)) + 
  geom_errorbar(mapping = aes(x = 1:100, ymin = lci_raw, ymax = uci_raw))
```

Ok, I want to look carefully at the bootstrapping results for matrix 3, which is one of the ones where it is non-sensical.

```{r}
testdata <- results$observations[[13]]
testboot <- boot.transitions(testdata, iterations = 10000)
quantile(testboot$lambda, p = c(0, 0.025, 0.975, 1))
results$lambdaraw[[13]]
```

So it is just really bad. The only CI that make sense are the ones where the observed lambda is > 1. 


What about a larger sample size, and only plants > 1 year old?

```{r}
set.seed(384768697)
initial_stages <- c(1, 1, 1, 1, 1, 1, 1, 1)
true_lambda <- lambda(TF$T + TF$F)
results <- tibble(observations = map(1:100, 
                                     function(x) sim_observations(TF, N = 500, initial_stages = initial_stages)),
       TF = map(observations, projection_matrix, fertility = "Sd", TF = TRUE),
       N = map(observations, get_state_vector),
       Tunif = map2(TF, N, fill_transitions, P = transition_prior),
       Funif = map2(TF, N, fill_fertility, alpha = fertility_alpha, beta = fertility_beta),
       A = map(TF, ~.x$T+.x$F),
       Aunif = map2(Tunif, Funif, ~.x + .y)) %>% 
  mutate(lambdaraw = map_dbl(A, lambda),
         bootraw = map(observations, boot.transitions, iterations = 1000),
         lci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.025)),
         uci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.975)),
         lambdaunif = map_dbl(Aunif, lambda))
results <- mutate(results,
                  goodci = lci_raw < true_lambda & uci_raw > true_lambda,
                  sensibleci = lci_raw < lambdaraw & uci_raw > lambdaraw)
ggplot(data = results) +
  geom_point(mapping = aes(x = 1:100, y = lambdaraw)) + 
  geom_errorbar(mapping = aes(x = 1:100, ymin = lci_raw, ymax = uci_raw,
                              color = goodci)) +
  geom_hline(yintercept = lambda(TF$T + TF$F), linetype = 2, color = "blue")
```

With a sample of 500 individuals only `r sum(results$goodci)` intervals
include the true population growth rate. Indeed, only `r sum(results$sensibleci)`
intervals even include the observed growth rate. 

To ensure this is not an artifact -- simulate observations from a "good" matrix and calculate bootstrap intervals. 

## Intervals from Bayesian posterior

```{r}
results <- results %>% 
  mutate(sim_TF = map2(TF, N, function(.x, .y) sim_transitions(TF = .x, 
                      N = .y, P = transition_prior, 
                      alpha = fertility_alpha, beta = fertility_beta, 
                      samples = 1000)))
results <- results %>% 
  mutate(sim_lambdas = map(sim_TF, function(ll) map_dbl(ll, lambda)),
         sim_lci = map_dbl(sim_lambdas, quantile, p = 0.025),
         sim_uci = map_dbl(sim_lambdas, quantile, p = 0.975),
         good_sci = sim_lci < true_lambda & sim_uci > true_lambda,
         sensible_sci = sim_lci < lambdaunif & sim_uci > lambdaunif)
ggplot(data = results) +
  geom_point(mapping = aes(x = 1:100, y = lambdaunif)) + 
  geom_errorbar(mapping = aes(x = 1:100, ymin = sim_lci, ymax = sim_uci,
                              color = good_sci)) +
  geom_hline(yintercept = lambda(TF$T + TF$F), linetype = 2, color = "blue")
```

So the coverage property of the posterior credible interval is much better. Moreover,
`r sum(results$sensible_sci)` out of 100 intervals are sensible in the sense that
the estimate from the observed data is inside the credible interval.

What about relative width of the intervals?

# what about conflicting priors?

One thing that might concern users is if the prior knowledge is incorrect or
misleading in some way. What are some ways this might happen? Missing possible
transitions? Including impossible transitions? Getting


# What about a different sampling strategy? 

If an ecologist uses a fixed area to get the sample, then using the stable stage
distribution would be a good initial vector. However, rarer stages could be
oversampled by searching for them. 

```{r}

set.seed(5786576)
initial_stages <- c(0.5, 1, 1, 1, 1, 2, 2, 5)
true_lambda <- lambda(TF$T + TF$F)
results <- tibble(observations = map(1:100, 
                                     function(x) sim_observations(TF, N = 500, initial_stages = initial_stages)),
       TF = map(observations, projection_matrix, fertility = "Sd", TF = TRUE),
       N = map(observations, get_state_vector),
       Tunif = map2(TF, N, fill_transitions, P = transition_prior),
       Funif = map2(TF, N, fill_fertility, alpha = fertility_alpha, beta = fertility_beta),
       A = map(TF, ~.x$T+.x$F),
       Aunif = map2(Tunif, Funif, ~.x + .y)) %>% 
  mutate(lambdaraw = map_dbl(A, lambda),
         bootraw = map(observations, boot.transitions, iterations = 1000),
         lci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.025)),
         uci_raw = map_dbl(bootraw, ~quantile(.$lambda, p = 0.975)),
         lambdaunif = map_dbl(Aunif, lambda))
results <- mutate(results,
                  goodci = lci_raw < true_lambda & uci_raw > true_lambda,
                  sensibleci = lci_raw < lambdaraw & uci_raw > lambdaraw)
ggplot(data = results) +
  geom_point(mapping = aes(x = 1:100, y = lambdaraw)) + 
  geom_errorbar(mapping = aes(x = 1:100, ymin = lci_raw, ymax = uci_raw,
                              color = goodci)) +
  geom_hline(yintercept = lambda(TF$T + TF$F), linetype = 2, color = "blue")
```

The bootstrapped intervals are even worse!! How about the Bayesian approach with
oversampled data?


```{r}
# no set seed because using results from previous chunk.
results <- results %>% 
  mutate(sim_TF = map2(TF, N, function(.x, .y) sim_transitions(TF = .x, 
                      N = .y, P = transition_prior, 
                      alpha = fertility_alpha, beta = fertility_beta, 
                      samples = 1000)))
results <- results %>% 
  mutate(sim_lambdas = map(sim_TF, function(ll) map_dbl(ll, lambda)),
         sim_lci = map_dbl(sim_lambdas, quantile, p = 0.025),
         sim_uci = map_dbl(sim_lambdas, quantile, p = 0.975),
         good_sci = sim_lci < true_lambda & sim_uci > true_lambda,
         sensible_sci = sim_lci < lambdaunif & sim_uci > lambdaunif)
ggplot(data = results) +
  geom_point(mapping = aes(x = 1:100, y = lambdaunif)) + 
  geom_errorbar(mapping = aes(x = 1:100, ymin = sim_lci, ymax = sim_uci,
                              color = good_sci)) +
  geom_hline(yintercept = lambda(TF$T + TF$F), linetype = 2, color = "blue")
```

These are still much better. 

# Caveats

Simulating matrices from the posterior ignores correlations between vital rates,
which might cause the credible intervals to be too narrow. I wonder if 
applying bootstrapped samples to the priors would be better? 
But the more I think about it, the less worried I am about that. I think the 
correlation between vital rates is in variation over time, and we’re just looking 
at a single transition. 




# Literature cited

Horvitz, C.C. and D.W. Schemske. 1995. Spatiotemporal variation in demographic transitions of a tropical understory herb: Projection matrix analysis. Ecological Monographs 65:155-192.
